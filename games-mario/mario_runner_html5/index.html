<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Mario Infinite Runner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        canvas {
            background-color: #5c94fc; /* Mario Sky Blue */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated; /* Sharp pixels */
        }
        #instructions {
            position: absolute;
            color: white;
            top: 20px;
            text-align: center;
            text-shadow: 2px 2px 0 #000;
            font-size: 18px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="instructions">PRESS SPACE or TAP to JUMP</div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const GRAVITY = 0.6;
        const JUMP_FORCE = -12;
        const GROUND_Y = 350;
        const SPAWN_RATE_INITIAL = 120; // Frames between spawns
        const MIN_SPAWN_RATE = 40;
        
        // Game State
        let frames = 0;
        let score = 0;
        let gameSpeed = 5;
        let isGameOver = false;
        let animationId;
        
        // Inputs
        let jumpPressed = false;

        // Assets (Procedural drawing functions to avoid external images)
        const Draw = {
            mario: (x, y, w, h) => {
                // Simple 8-bit style representation using rectangles
                // Body/Shirt (Red)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(x + 4, y + 10, 24, 20);
                
                // Overalls (Blue)
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(x + 4, y + 24, 24, 16);
                ctx.fillRect(x + 8, y + 20, 4, 10); // strap
                ctx.fillRect(x + 20, y + 20, 4, 10); // strap

                // Head (Skin)
                ctx.fillStyle = '#ffcc99';
                ctx.fillRect(x + 6, y + 2, 20, 18);

                // Hat (Red)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(x + 4, y, 28, 6);
                ctx.fillRect(x + 4, y, 16, 10); // Hat brim/top
                
                // Mustache (Black)
                ctx.fillStyle = '#000000';
                ctx.fillRect(x + 18, y + 14, 10, 4);
                ctx.fillRect(x + 18, y + 12, 4, 2); // Nose detail
            },
            goomba: (x, y, w, h) => {
                // Head (Brown)
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(x, y, w, h - 10);
                // Eyes (White/Black)
                ctx.fillStyle = '#fff';
                ctx.fillRect(x + 6, y + 8, 8, 8);
                ctx.fillRect(x + 18, y + 8, 8, 8);
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 8, y + 10, 4, 4);
                ctx.fillRect(x + 20, y + 10, 4, 4);
                // Feet (Black)
                ctx.fillStyle = '#000';
                if (frames % 20 < 10) {
                   ctx.fillRect(x - 2, y + h - 10, 12, 10); // Left foot forward
                   ctx.fillRect(x + 18, y + h - 10, 12, 10);
                } else {
                   ctx.fillRect(x + 2, y + h - 10, 12, 10); 
                   ctx.fillRect(x + 22, y + h - 10, 12, 10); // Right foot forward
                }
            },
            pipe: (x, y, w, h) => {
                ctx.fillStyle = '#00aa00'; // Light green
                ctx.fillRect(x, y, w, h);
                ctx.fillStyle = '#008800'; // Darker green outline/shade
                ctx.fillRect(x + 4, y, w - 8, h);
                
                // Pipe Cap
                ctx.fillStyle = '#00aa00';
                ctx.fillRect(x - 4, y, w + 8, 20);
                ctx.fillStyle = '#008800';
                ctx.fillRect(x, y, w, 20);
                
                // Highlights
                ctx.fillStyle = '#88ff88';
                ctx.fillRect(x + 10, y + 5, 4, h - 5);
                ctx.fillRect(x + 10, y, 4, 20); // Cap highlight
            },
            ground: () => {
                ctx.fillStyle = '#c84c0c'; // Brick brown
                ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
                
                // Brick pattern
                ctx.fillStyle = '#b03c00'; // Darker grout
                ctx.lineWidth = 2;
                
                const brickW = 40;
                const brickH = 20;
                const offset = (frames * gameSpeed) % brickW;
                
                for (let y = GROUND_Y; y < canvas.height; y += brickH) {
                    for (let x = -offset; x < canvas.width; x += brickW) {
                        ctx.fillRect(x + 2, y + 2, brickW - 4, brickH - 4);
                    }
                }
                
                // Top grass line
                ctx.fillStyle = '#00aa00';
                ctx.fillRect(0, GROUND_Y, canvas.width, 10);
            },
            cloud: (x, y) => {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, Math.PI * 2);
                ctx.arc(x + 25, y - 10, 25, 0, Math.PI * 2);
                ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
                ctx.fill();
            },
            bush: (x, y) => {
                ctx.fillStyle = '#008800';
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.arc(x + 20, y - 5, 20, 0, Math.PI * 2);
                ctx.arc(x + 40, y, 15, 0, Math.PI * 2);
                ctx.fill();
            }
        };

        class Player {
            constructor() {
                this.w = 32;
                this.h = 40;
                this.x = 50;
                this.y = GROUND_Y - this.h;
                this.dy = 0;
                this.isGrounded = true;
                this.isDucking = false;
            }

            jump() {
                if (this.isGrounded) {
                    this.dy = JUMP_FORCE;
                    this.isGrounded = false;
                }
            }

            update() {
                // Apply Gravity
                this.dy += GRAVITY;
                this.y += this.dy;

                // Ground Collision
                if (this.y + this.h > GROUND_Y) {
                    this.y = GROUND_Y - this.h;
                    this.dy = 0;
                    this.isGrounded = true;
                }
            }

            draw() {
                Draw.mario(this.x, this.y, this.w, this.h);
            }
        }

        class Obstacle {
            constructor() {
                this.type = Math.random() < 0.6 ? 'goomba' : 'pipe';
                this.w = this.type === 'pipe' ? 40 : 32;
                this.h = this.type === 'pipe' ? (Math.random() < 0.5 ? 40 : 60) : 32;
                this.x = canvas.width;
                this.y = GROUND_Y - this.h;
                this.markedForDeletion = false;
            }

            update() {
                this.x -= gameSpeed;
                if (this.x + this.w < 0) this.markedForDeletion = true;
            }

            draw() {
                if (this.type === 'pipe') {
                    Draw.pipe(this.x, this.y, this.w, this.h);
                } else {
                    Draw.goomba(this.x, this.y, this.w, this.h);
                }
            }
        }

        class BackgroundElement {
            constructor(type, speedFactor, yRange) {
                this.type = type;
                this.x = canvas.width + Math.random() * 200;
                this.y = Math.random() * yRange + 50;
                this.speedFactor = speedFactor;
                this.markedForDeletion = false;
            }

            update() {
                this.x -= gameSpeed * this.speedFactor;
                if (this.x + 100 < 0) this.markedForDeletion = true;
            }

            draw() {
                if (this.type === 'cloud') Draw.cloud(this.x, this.y);
                if (this.type === 'bush') Draw.bush(this.x, GROUND_Y - 10);
            }
        }

        let player = new Player();
        let obstacles = [];
        let bgElements = [];
        let spawnTimer = 0;
        
        function spawnObstacles() {
            spawnTimer--;
            if (spawnTimer <= 0) {
                obstacles.push(new Obstacle());
                // Accelerate spawn rate slightly as game progresses
                spawnTimer = SPAWN_RATE_INITIAL - Math.min(score * 0.05, SPAWN_RATE_INITIAL - MIN_SPAWN_RATE) + Math.random() * 30;
            }
        }

        function spawnBackground() {
            if (Math.random() < 0.01) {
                bgElements.push(new BackgroundElement('cloud', 0.2, 100));
            }
            if (Math.random() < 0.005) {
                bgElements.push(new BackgroundElement('bush', 0.5, 0));
            }
        }

        function checkCollisions() {
            for (let obs of obstacles) {
                if (
                    player.x < obs.x + obs.w &&
                    player.x + player.w > obs.x &&
                    player.y < obs.y + obs.h &&
                    player.y + player.h > obs.y
                ) {
                    return true;
                }
            }
            return false;
        }

        function resetGame() {
            player = new Player();
            obstacles = [];
            bgElements = [];
            score = 0;
            gameSpeed = 5;
            spawnTimer = 0;
            isGameOver = false;
            frames = 0;
            animate();
        }

        function drawScore() {
            ctx.fillStyle = 'white';
            ctx.font = '20px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText(`SCORE: ${Math.floor(score)}`, canvas.width - 20, 30);
            
            // High score (if we were saving it, but simple for now)
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = '40px Courier New';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 20);
            
            ctx.font = '20px Courier New';
            ctx.fillText('Press Space to Restart', canvas.width/2, canvas.height/2 + 20);
        }

        function animate() {
            if (isGameOver) {
                drawGameOver();
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update
            frames++;
            score += 0.1;
            gameSpeed += 0.001; // Slow acceleration

            spawnObstacles();
            spawnBackground();
            player.update();

            bgElements.forEach(bg => bg.update());
            obstacles.forEach(obs => obs.update());

            // Cleanup
            obstacles = obstacles.filter(o => !o.markedForDeletion);
            bgElements = bgElements.filter(bg => !bg.markedForDeletion);

            // Collisions
            if (checkCollisions()) {
                isGameOver = true;
            }

            // Draw
            // Sky is css background
            bgElements.forEach(bg => bg.draw());
            Draw.ground();
            obstacles.forEach(obs => obs.draw());
            player.draw();
            drawScore();

            animationId = requestAnimationFrame(animate);
        }

        // Input Handling
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                if (isGameOver) {
                    resetGame();
                } else {
                    player.jump();
                }
                e.preventDefault();
            }
        });

        window.addEventListener('touchstart', (e) => {
             if (isGameOver) {
                resetGame();
            } else {
                player.jump();
            }
            e.preventDefault();
        }, {passive: false});

        // Start
        animate();

    </script>
</body>
</html>
